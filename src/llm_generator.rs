//! LLM-based command generation using Claude API.
//!
//! This module provides AI-powered command generation capabilities. When a user
//! requests a command that doesn't exist, the LLM generates a Deno/TypeScript
//! script that implements the requested functionality.

use crate::http_client::{HttpClient, ReqwestHttpClient};
use anyhow::{anyhow, Result};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::json;
use tracing::info;

// =============================================================================
// Data Types
// =============================================================================

/// A permission request for a generated command.
///
/// Each permission specifies what access the command needs (e.g., file read,
/// network access) and a human-readable reason explaining why.
///
/// # Example
///
/// ```
/// use abiogenesis::llm_generator::PermissionRequest;
///
/// let perm = PermissionRequest {
///     permission: "--allow-read".to_string(),
///     reason: "Read configuration files from current directory".to_string(),
/// };
/// ```
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PermissionRequest {
    /// The Deno permission flag (e.g., "--allow-read", "--allow-net").
    pub permission: String,
    /// Human-readable explanation of why this permission is needed.
    pub reason: String,
}

/// A command generated by the LLM.
///
/// Contains metadata about the command and a reference to its script file.
/// The actual script content is stored separately in the cache.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct GeneratedCommand {
    /// The command name (used for invocation and caching).
    pub name: String,
    /// Human-readable description of what the command does.
    pub description: String,
    /// Path to the script file (relative to biomas directory).
    pub script_file: String,
    /// List of Deno permissions required by this command.
    pub permissions: Vec<PermissionRequest>,
}

/// Result of generating a command, including the script content.
///
/// This struct bundles the command metadata with the actual script source code
/// that will be executed by Deno.
#[derive(Debug)]
pub struct GenerationResult {
    /// The generated command metadata.
    pub command: GeneratedCommand,
    /// The TypeScript/JavaScript source code to execute.
    pub script_content: String,
}

// =============================================================================
// Command Generator Trait
// =============================================================================

/// Trait for command generation backends.
///
/// This trait abstracts command generation, allowing different implementations
/// (e.g., real LLM API, mock for testing).
#[async_trait]
pub trait CommandGenerator: Send + Sync {
    /// Generates a command with the given name and arguments.
    ///
    /// # Arguments
    ///
    /// * `command_name` - The name to use for the generated command
    /// * `args` - Arguments that the command should handle
    ///
    /// # Returns
    ///
    /// A `GenerationResult` containing the command metadata and script content.
    async fn generate_command(&self, command_name: &str, args: &[String]) -> Result<GenerationResult>;
}

// =============================================================================
// LLM Generator Implementation
// =============================================================================

/// LLM-based command generator using Claude API.
///
/// Uses the Anthropic Claude API to generate Deno/TypeScript commands based on
/// natural language descriptions or command names.
pub struct LlmGenerator<H: HttpClient = ReqwestHttpClient> {
    http_client: H,
}

impl LlmGenerator<ReqwestHttpClient> {
    /// Creates a new LlmGenerator with the default HTTP client.
    pub fn new() -> Self {
        Self {
            http_client: ReqwestHttpClient::new(),
        }
    }
}

impl Default for LlmGenerator<ReqwestHttpClient> {
    fn default() -> Self {
        Self::new()
    }
}

impl<H: HttpClient> LlmGenerator<H> {
    /// Creates a new LlmGenerator with a custom HTTP client.
    ///
    /// This is primarily useful for testing with mock HTTP responses.
    pub fn with_http_client(http_client: H) -> Self {
        Self { http_client }
    }

    /// Generates a command from a natural language description.
    ///
    /// Unlike `generate_command`, this method lets Claude suggest the command name
    /// based on the description.
    ///
    /// # Arguments
    ///
    /// * `description` - Natural language description of what the command should do
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - No API key is configured
    /// - The API request fails
    /// - The response cannot be parsed
    pub async fn generate_command_from_description(&self, description: &str) -> Result<GenerationResult> {
        info!("Generating command from description: {}", description);

        let config = crate::config::Config::load()?;

        if let Some(api_key) = config.get_api_key() {
            info!("Using Claude API for conversational command generation");
            let prompt = self.build_unified_prompt(description, None);
            self.call_claude_api_with_prompt(&prompt, api_key).await
        } else {
            Err(Self::api_key_missing_error())
        }
    }

    // -------------------------------------------------------------------------
    // Internal helpers
    // -------------------------------------------------------------------------

    async fn generate_command_impl(&self, command_name: &str, args: &[String]) -> Result<GenerationResult> {
        let config = crate::config::Config::load()?;

        if let Some(api_key) = config.get_api_key() {
            info!("Using Claude API for command generation");
            let prompt = self.build_unified_prompt(command_name, Some(args));
            let mut result = self.call_claude_api_with_prompt(&prompt, api_key).await?;
            // Override Claude's suggested name with the user's specified name
            result.command.name = command_name.to_string();
            result.command.script_file = format!("{}.ts", command_name);
            Ok(result)
        } else {
            Err(Self::api_key_missing_error())
        }
    }

    fn api_key_missing_error() -> anyhow::Error {
        anyhow!(
            "No Anthropic API key found. Please set it using one of these methods:\n\
            \n\
            1. Set API key in config:\n\
               ergo --set-api-key sk-ant-your-key-here\n\
            \n\
            2. Set environment variable:\n\
               export ANTHROPIC_API_KEY=sk-ant-your-key-here\n\
            \n\
            3. Check current config:\n\
               ergo --config\n\
            \n\
            Get your API key from: https://console.anthropic.com"
        )
    }

    fn build_unified_prompt(&self, request: &str, args: Option<&[String]>) -> String {
        let request_description = if let Some(args) = args {
            format!("Create a command named '{}' that handles arguments {:?}", request, args)
        } else {
            request.to_string()
        };

        format!(
            "CRITICAL: Your response must be EXACTLY a JSON object. No explanations, no code blocks, no other text.

Based on this request: \"{}\"

Create a Deno/TypeScript command and suggest a short, descriptive command name.

RESPOND WITH EXACTLY THIS FORMAT (with your values):
{{
  \"name\": \"suggested-command-name\",
  \"description\": \"Brief description of what this command does\",
  \"script\": \"console.log('working code here');\",
  \"permissions\": [
    {{
      \"permission\": \"--allow-read\",
      \"reason\": \"Read files from the current directory\"
    }}
  ]
}}

RULES:
- Choose a clear, short command name (2-3 words max, kebab-case)
- Create real, working functionality - no placeholder code
- Use Deno APIs when needed
- Arguments available as Deno.args if the command should accept them
- Use MINIMAL permissions (empty [] preferred)
- Valid permission values: --allow-read, --allow-write, --allow-net, --allow-env, --allow-run
- For each permission, provide a clear reason why it's needed in user-friendly language
- Include try/catch for error handling
- CRITICAL: RESPOND ONLY WITH THE JSON OBJECT ABOVE - NO OTHER TEXT",
            request_description
        )
    }

    async fn call_claude_api_with_prompt(&self, prompt: &str, api_key: &str) -> Result<GenerationResult> {
        let request_body = json!({
            "model": "claude-3-haiku-20240307",
            "max_tokens": 1500,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        });

        let headers = [
            ("x-api-key", api_key),
            ("content-type", "application/json"),
            ("anthropic-version", "2023-06-01"),
        ];

        let response_text = self
            .http_client
            .post_json("https://api.anthropic.com/v1/messages", &headers, &request_body)
            .await?;

        info!("Claude API response: {}", response_text);

        Self::parse_claude_response(&response_text)
    }

    /// Parses the Claude API response and extracts the generated command.
    ///
    /// This is separated from the HTTP call to enable unit testing of the
    /// parsing logic without making actual API requests.
    fn parse_claude_response(response_text: &str) -> Result<GenerationResult> {
        // Internal struct for deserializing Claude's JSON response
        #[derive(Debug, Deserialize)]
        struct ClaudeCommandResponse {
            name: String,
            description: String,
            script: String,
            permissions: Vec<PermissionRequest>,
        }

        // Parse the outer Claude API response
        let api_response: serde_json::Value = serde_json::from_str(response_text)
            .map_err(|_| anyhow!("Failed to parse Claude response as JSON: {}", response_text))?;

        // Extract the text content from Claude's response
        let content = api_response
            .get("content")
            .and_then(|c| c.as_array())
            .and_then(|arr| arr.first())
            .and_then(|item| item.get("text"))
            .and_then(|text| text.as_str())
            .ok_or_else(|| anyhow!("Failed to extract content from Claude response"))?;

        info!("Extracted content from Claude: {}", content);

        // Parse the generated command JSON
        let command_response: ClaudeCommandResponse = serde_json::from_str(content)
            .map_err(|e| anyhow!("Failed to parse generated command JSON: {}. Content: {}", e, content))?;

        info!("Successfully parsed Claude-generated command");

        Ok(GenerationResult {
            command: GeneratedCommand {
                name: command_response.name.clone(),
                description: command_response.description,
                script_file: format!("{}.ts", command_response.name),
                permissions: command_response.permissions,
            },
            script_content: command_response.script,
        })
    }
}

#[async_trait]
impl<H: HttpClient> CommandGenerator for LlmGenerator<H> {
    async fn generate_command(&self, command_name: &str, args: &[String]) -> Result<GenerationResult> {
        info!("Generating command for: {} with args: {:?}", command_name, args);
        self.generate_command_impl(command_name, args).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // =========================================================================
    // Data type deserialization tests
    // =========================================================================

    #[test]
    fn test_permission_request_deserialization() {
        let json = r#"{"permission": "--allow-net", "reason": "Network access"}"#;
        let perm: PermissionRequest = serde_json::from_str(json).unwrap();

        assert_eq!(perm.permission, "--allow-net");
        assert_eq!(perm.reason, "Network access");
    }

    #[test]
    fn test_generated_command_deserialization() {
        let json = r#"{
            "name": "hello",
            "description": "Says hello",
            "script_file": "hello.ts",
            "permissions": []
        }"#;

        let cmd: GeneratedCommand = serde_json::from_str(json).unwrap();
        assert_eq!(cmd.name, "hello");
        assert_eq!(cmd.description, "Says hello");
        assert_eq!(cmd.script_file, "hello.ts");
        assert!(cmd.permissions.is_empty());
    }

    #[test]
    fn test_generated_command_deserialization_with_permissions() {
        let json = r#"{
            "name": "fetch",
            "description": "Fetches data",
            "script_file": "fetch.ts",
            "permissions": [
                {"permission": "--allow-net", "reason": "Network"},
                {"permission": "--allow-read", "reason": "Read files"}
            ]
        }"#;

        let cmd: GeneratedCommand = serde_json::from_str(json).unwrap();
        assert_eq!(cmd.permissions.len(), 2);
        assert_eq!(cmd.permissions[0].permission, "--allow-net");
        assert_eq!(cmd.permissions[1].permission, "--allow-read");
    }

    // =========================================================================
    // Claude API response parsing tests
    // =========================================================================

    #[test]
    fn test_parse_claude_response_success() {
        let response = r#"{
            "content": [
                {
                    "type": "text",
                    "text": "{\"name\": \"hello\", \"description\": \"Greets the user\", \"script\": \"console.log('Hello!');\", \"permissions\": []}"
                }
            ]
        }"#;

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response).unwrap();

        assert_eq!(result.command.name, "hello");
        assert_eq!(result.command.description, "Greets the user");
        assert_eq!(result.command.script_file, "hello.ts");
        assert_eq!(result.script_content, "console.log('Hello!');");
        assert!(result.command.permissions.is_empty());
    }

    #[test]
    fn test_parse_claude_response_with_permissions() {
        let response = r#"{
            "content": [
                {
                    "type": "text",
                    "text": "{\"name\": \"fetch-data\", \"description\": \"Fetches data\", \"script\": \"await fetch('url');\", \"permissions\": [{\"permission\": \"--allow-net\", \"reason\": \"Network access\"}]}"
                }
            ]
        }"#;

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response).unwrap();

        assert_eq!(result.command.name, "fetch-data");
        assert_eq!(result.command.permissions.len(), 1);
        assert_eq!(result.command.permissions[0].permission, "--allow-net");
        assert_eq!(result.command.permissions[0].reason, "Network access");
    }

    #[test]
    fn test_parse_claude_response_invalid_json() {
        let response = "not valid json";

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_claude_response_missing_content() {
        let response = r#"{"error": "something went wrong"}"#;

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_claude_response_invalid_command_json() {
        let response = r#"{
            "content": [
                {
                    "type": "text",
                    "text": "This is not valid JSON for a command"
                }
            ]
        }"#;

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_claude_response_empty_content_array() {
        let response = r#"{"content": []}"#;

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response);
        assert!(result.is_err());
    }

    #[test]
    fn test_parse_claude_response_missing_text_field() {
        let response = r#"{
            "content": [
                {
                    "type": "text"
                }
            ]
        }"#;

        let result = LlmGenerator::<ReqwestHttpClient>::parse_claude_response(response);
        assert!(result.is_err());
    }
}
